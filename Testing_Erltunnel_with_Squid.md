# Testing Erltunnel with Squid #
Using Erltunnel is pretty simple, you just have to start the client and server with appropriate parameters.
As an example, we show how to start them in a local test environment where the client has to pass a local Squid proxy listening on its standard port 3128.

First, start the tunnel server at some running Erlang node using `erltunnel:start_server` with a name for this server and its listening port as parameters, e.g.
```
erltunnel:start_server(tunnelserver, 3000).
```
The server is registered as a gen\_server process under the specified name.

Then start the tunnel client at another local Erlang node using the function `start_client`.
The mandatory parameters are a name, a port number for incoming connections and the tunnel server address consisting of its IP and port.
In the same manner the client is registered as a gen\_server process under this name.
An optional proxy located between tunnel client and server is specified by its address and some username and password for authentication.
Thus, the tunnel client is started by
```
erltunnel:start_client(tunnelclient, 3003, {"127.0.0.1", 3000}, {{"127.0.0.1", 3128}, {"erlanguser", "erlangpasswd"}}).
```
When there is no intermediate proxy, the atom `noProxy` must be passed as proxy parameter.

## Erltunnel in action ##
To show Erltunnel in action, the Erlang shell output of both the tunnel client and server is given below.
Here a Firefox web browser where the tunnel client is defined as its SOCKS 4 proxy loads the Google homepage through the tunnel.
In its default logging mode, the client and server provide some information about new or terminated tunnel connections.
Such a log entry contains the identifier (an integer counter) of the tunnel connection and the two remote socket addresses between which the tunnel client or server, respectively, relays data.
For the tunnel client these are the socket addresses to the Firefox browser and the proxy.
And for the tunnel server these are the socket addresses to the proxy and the destination Google host.
Additionally, each log entry contains the current number of active tunnel connections.

What you might wondering about are the reconnection log entries generated by the tunnel server.
This is due to how Squid handles outgoing connections.
Firefox tries to load the Google page over a persistent HTTP/1.1 connection, i.e. all resource files located at the same host are loaded using the same TCP connection.
Whereas Squid keeps the connection to the tunnel client alive to allow sending multiple HTTP requests/responses over the same connection, it uses for each HTTP request/response a single TCP connection to the tunnel server.
Thus, Squid seems to handle outgoing connections like non-persistent HTTP connections.
In such a situation, the tunnel server keeps the tunnel connection alive by waiting for the proxy to open again an HTTP connection that continues the tunnel connection.
The Erltunnel client and server use an internal protocol wrapped in the body of their HTTP request/response cycles that transports both the user data and the tunnel connection identifier.

### Erltunnel client output ###
```
Erlang (BEAM) emulator version 5.5.5 [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.5.5  (abort with ^G)
1> erltunnel:start_client(tunnelclient, 3003, {"127.0.0.1", 3000}, {{"127.0.0.1", 3128}, {"erlanguser", "erlangpasswd"}}).
tunnelclient listens on port 3003.
{ok,<0.33.0>}
info tunnelclient [1 connections]:
  new_connection : "ID 2, Pid <0.34.0>, 127.0.0.1:4215 -> 127.0.0.1:3128"
info tunnelclient [0 connections]:
  close_connection : "ID 2, Pid <0.34.0>, 127.0.0.1:4215 -> 127.0.0.1:3128"
```

### Erltunnel server output ###
```
Erlang (BEAM) emulator version 5.5.5 [source] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.5.5  (abort with ^G)
1> erltunnel:start_server(tunnelserver, 3000).
tunnelserver listens on port 3000.
{ok,<0.33.0>}
info tunnelserver [1 connections]:
  new_connection : "ID 2, Pid <0.34.0>, 127.0.0.1:3966 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:1731 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4747 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:2522 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4548 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:1380 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4498 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4374 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4410 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:4891 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:3439 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:2463 -> 209.85.129.104:80"
info tunnelserver [1 connections]:
  reconnected : "ID 2, Pid <0.34.0>, 127.0.0.1:2832 -> 209.85.129.104:80"
info tunnelserver [0 connections]:
  close_connection : "ID 2, Pid <0.34.0>, 127.0.0.1:2832 -> 209.85.129.104:80"
```